<script lang="ts">
    export let octaves = 2;
    export let middleC = 60;
    export let keysPressed = [];
    export let verbose;

    const modulo = octaves * 12;

    import Key from "./Key.svelte";
    import { onMount } from "svelte";
    import MIDI from "midi.js";

    let keys;

    $: keys = [...Array(octaves * 12 + 1).keys()].map(
        (i) => i + (middleC - Math.floor(octaves / 2) * 12),
    );

    let logs = [];

    function noteOn(note: number, velocity: number = 127) {
        logs = [`Note ${note} was pressed!`, ...logs];

        MIDI.noteOn(0, note, velocity, 0);
    }

    function noteOff(note: number) {
        logs = [`Note ${note} was released!`, ...logs];

        MIDI.noteOff(0, note, 0);
    }

    function listInputsAndOutputs(midiAccess: WebMidi.MIDIAccess) {
        for (const entry of midiAccess.inputs) {
            const input = entry[1];
            console.log(
                "Input port [type:'" +
                    input.type +
                    "'] id:'" +
                    input.id +
                    "' manufacturer:'" +
                    input.manufacturer +
                    "' name:'" +
                    input.name +
                    "' version:'" +
                    input.version +
                    "'",
            );
        }

        for (const entry of midiAccess.outputs) {
            const output = entry[1];
            console.log(
                "Output port [type:'" +
                    output.type +
                    "'] id:'" +
                    output.id +
                    "' manufacturer:'" +
                    output.manufacturer +
                    "' name:'" +
                    output.name +
                    "' version:'" +
                    output.version +
                    "'",
            );
        }
    }

    function onMIDIMessage(event: WebMidi.MIDIMessageEvent) {
        if (verbose) {
            let str =
                "MIDI message received at timestamp " +
                event.timeStamp +
                "[" +
                event.data.length +
                " bytes]: ";
            for (let i = 0; i < event.data.length; i++) {
                str += "0x" + event.data[i].toString(16) + " ";
                event.data;
            }
            console.log(str);
        }

        const command = event.data[0];
        const key = event.data[1] % modulo;
        const velocity = event.data.length > 2 ? event.data[2] : 0; // a velocity value might not be included with a noteOff command

        switch (command) {
            case 144: // noteOn
                if (velocity > 0) {
                    keyBindings[key]?.keyPressed(key);
                } else {
                    keyBindings[key]?.keyReleased(key);
                }
                break;
            case 128: // noteOff
                keyBindings[key]?.keyReleased(key);
                break;
            // we could easily expand this switch statement to cover other types of commands such as controllers or sysex
        }
    }

    onMount(async () => {
        MIDI.loadPlugin({
            soundfontUrl: "./soundfont/",
            instrument: "acoustic_grand_piano",
            onprogress: function (state, progress) {
                console.log(state, progress);
            },
            onsuccess: function () {
                MIDI.setVolume(0, 127);
            },
        });
        try {
            let midiAccess = await navigator.requestMIDIAccess();
            console.log("MIDI ready!");
            if (verbose) listInputsAndOutputs(midiAccess);
            midiAccess.inputs.forEach((entry) => {
                entry.onmidimessage = onMIDIMessage;
            });
        } catch (err) {
            console.log("Failed to get MIDI access - " + err);
        }
    });

    let keyBindings = {};

    let innerWidth: number;
    $: keyWidth = Math.min((innerWidth - 36 / octaves) / (octaves * 8), 56);
</script>

<svelte:window bind:innerWidth />

<div class="keyboard">
    <div>
        {#each keys as note}
            <Key
                noteNum={note}
                {keyWidth}
                on:noteon={({ detail }) => noteOn(detail)}
                on:noteoff={({ detail }) => noteOff(detail)}
                pressed={keysPressed.includes(note)}
                bind:this={keyBindings[note % modulo]}
            />
        {/each}
    </div>
</div>

{#if verbose}
    {#each logs as log}
        <div>{log}</div>
    {/each}
{/if}

<style>
    .keyboard {
        display: flex;
        justify-content: center;
    }
    .keyboard > div {
        display: flex;
        overflow: auto;
        padding: 8px;
        height: 192px;
    }
</style>
